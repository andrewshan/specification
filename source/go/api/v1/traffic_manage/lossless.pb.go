// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lossless.proto

package traffic_manage // import "github.com/polarismesh/specification/source/go/api/v1/traffic_manage"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DelayRegister_DelayStrategy int32

const (
	// register instance after delay specific time
	DelayRegister_DELAY_BY_TIME DelayRegister_DelayStrategy = 0
	// register instance until health check successfully
	DelayRegister_DELAY_BY_HEALTH_CHECK DelayRegister_DelayStrategy = 1
)

var DelayRegister_DelayStrategy_name = map[int32]string{
	0: "DELAY_BY_TIME",
	1: "DELAY_BY_HEALTH_CHECK",
}
var DelayRegister_DelayStrategy_value = map[string]int32{
	"DELAY_BY_TIME":         0,
	"DELAY_BY_HEALTH_CHECK": 1,
}

func (x DelayRegister_DelayStrategy) String() string {
	return proto.EnumName(DelayRegister_DelayStrategy_name, int32(x))
}
func (DelayRegister_DelayStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{2, 0}
}

// 优雅上下线规则的模型
type LosslessRule struct {
	// rule id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// service for rule belongs to
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// namespace for rule belongs to
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// revision routing version
	Revision string `protobuf:"bytes,4,opt,name=revision,proto3" json:"revision,omitempty"`
	// ctime create time of the rules
	Ctime string `protobuf:"bytes,5,opt,name=ctime,proto3" json:"ctime,omitempty"`
	// mtime modify time of the rules
	Mtime string `protobuf:"bytes,6,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// configuration for lossless online
	LosslessOnline *LosslessOnline `protobuf:"bytes,7,opt,name=losslessOnline,json=lossless_online,proto3" json:"losslessOnline,omitempty"`
	// configuration for lossless offline
	LosslessOffline *LosslessOffline `protobuf:"bytes,8,opt,name=losslessOffline,json=lossless_offline,proto3" json:"losslessOffline,omitempty"`
	// rule labels
	Metadata map[string]string `protobuf:"bytes,9,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 操作标志位
	Editable             bool     `protobuf:"varint,30,opt,name=editable,proto3" json:"editable,omitempty"`
	Deleteable           bool     `protobuf:"varint,31,opt,name=deleteable,proto3" json:"deleteable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LosslessRule) Reset()         { *m = LosslessRule{} }
func (m *LosslessRule) String() string { return proto.CompactTextString(m) }
func (*LosslessRule) ProtoMessage()    {}
func (*LosslessRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{0}
}
func (m *LosslessRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LosslessRule.Unmarshal(m, b)
}
func (m *LosslessRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LosslessRule.Marshal(b, m, deterministic)
}
func (dst *LosslessRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LosslessRule.Merge(dst, src)
}
func (m *LosslessRule) XXX_Size() int {
	return xxx_messageInfo_LosslessRule.Size(m)
}
func (m *LosslessRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LosslessRule.DiscardUnknown(m)
}

var xxx_messageInfo_LosslessRule proto.InternalMessageInfo

func (m *LosslessRule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LosslessRule) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *LosslessRule) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LosslessRule) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *LosslessRule) GetCtime() string {
	if m != nil {
		return m.Ctime
	}
	return ""
}

func (m *LosslessRule) GetMtime() string {
	if m != nil {
		return m.Mtime
	}
	return ""
}

func (m *LosslessRule) GetLosslessOnline() *LosslessOnline {
	if m != nil {
		return m.LosslessOnline
	}
	return nil
}

func (m *LosslessRule) GetLosslessOffline() *LosslessOffline {
	if m != nil {
		return m.LosslessOffline
	}
	return nil
}

func (m *LosslessRule) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *LosslessRule) GetEditable() bool {
	if m != nil {
		return m.Editable
	}
	return false
}

func (m *LosslessRule) GetDeleteable() bool {
	if m != nil {
		return m.Deleteable
	}
	return false
}

type LosslessOnline struct {
	// configuration for delayRegister
	DelayRegister *DelayRegister `protobuf:"bytes,1,opt,name=delayRegister,json=delay_register,proto3" json:"delayRegister,omitempty"`
	// configuration for warmup
	Warmup *Warmup `protobuf:"bytes,2,opt,name=warmup,proto3" json:"warmup,omitempty"`
	// configuration for readiness probe
	Readiness            *Readiness `protobuf:"bytes,3,opt,name=readiness,proto3" json:"readiness,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LosslessOnline) Reset()         { *m = LosslessOnline{} }
func (m *LosslessOnline) String() string { return proto.CompactTextString(m) }
func (*LosslessOnline) ProtoMessage()    {}
func (*LosslessOnline) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{1}
}
func (m *LosslessOnline) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LosslessOnline.Unmarshal(m, b)
}
func (m *LosslessOnline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LosslessOnline.Marshal(b, m, deterministic)
}
func (dst *LosslessOnline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LosslessOnline.Merge(dst, src)
}
func (m *LosslessOnline) XXX_Size() int {
	return xxx_messageInfo_LosslessOnline.Size(m)
}
func (m *LosslessOnline) XXX_DiscardUnknown() {
	xxx_messageInfo_LosslessOnline.DiscardUnknown(m)
}

var xxx_messageInfo_LosslessOnline proto.InternalMessageInfo

func (m *LosslessOnline) GetDelayRegister() *DelayRegister {
	if m != nil {
		return m.DelayRegister
	}
	return nil
}

func (m *LosslessOnline) GetWarmup() *Warmup {
	if m != nil {
		return m.Warmup
	}
	return nil
}

func (m *LosslessOnline) GetReadiness() *Readiness {
	if m != nil {
		return m.Readiness
	}
	return nil
}

type DelayRegister struct {
	// enable delay registry
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	// delay register strategy
	Strategy DelayRegister_DelayStrategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=v1.DelayRegister_DelayStrategy" json:"strategy,omitempty"`
	// delay register time by second, active when strategy == DELAY_BY_TIME
	IntervalSecond int32 `protobuf:"varint,3,opt,name=intervalSecond,json=interval_second,proto3" json:"intervalSecond,omitempty"`
	// protocol to do health check, default http, active when strategy == DELAY_BY_HEALTH_CHECK
	HealthCheckProtocol string `protobuf:"bytes,4,opt,name=healthCheckProtocol,json=health_check_protocol,proto3" json:"healthCheckProtocol,omitempty"`
	// method to do health check, default GET, active when strategy == DELAY_BY_HEALTH_CHECK
	HealthCheckMethod string `protobuf:"bytes,5,opt,name=healthCheckMethod,json=health_check_method,proto3" json:"healthCheckMethod,omitempty"`
	// path to do health check, no default value, active when strategy == DELAY_BY_HEALTH_CHECK
	HealthCheckPath string `protobuf:"bytes,6,opt,name=healthCheckPath,json=health_check_path,proto3" json:"healthCheckPath,omitempty"`
	// health check interval second, default is 30, active when strategy == DELAY_BY_HEALTH_CHECK
	HealthCheckIntervalSecond string   `protobuf:"bytes,7,opt,name=healthCheckIntervalSecond,json=health_check_interval_second,proto3" json:"healthCheckIntervalSecond,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *DelayRegister) Reset()         { *m = DelayRegister{} }
func (m *DelayRegister) String() string { return proto.CompactTextString(m) }
func (*DelayRegister) ProtoMessage()    {}
func (*DelayRegister) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{2}
}
func (m *DelayRegister) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DelayRegister.Unmarshal(m, b)
}
func (m *DelayRegister) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DelayRegister.Marshal(b, m, deterministic)
}
func (dst *DelayRegister) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelayRegister.Merge(dst, src)
}
func (m *DelayRegister) XXX_Size() int {
	return xxx_messageInfo_DelayRegister.Size(m)
}
func (m *DelayRegister) XXX_DiscardUnknown() {
	xxx_messageInfo_DelayRegister.DiscardUnknown(m)
}

var xxx_messageInfo_DelayRegister proto.InternalMessageInfo

func (m *DelayRegister) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *DelayRegister) GetStrategy() DelayRegister_DelayStrategy {
	if m != nil {
		return m.Strategy
	}
	return DelayRegister_DELAY_BY_TIME
}

func (m *DelayRegister) GetIntervalSecond() int32 {
	if m != nil {
		return m.IntervalSecond
	}
	return 0
}

func (m *DelayRegister) GetHealthCheckProtocol() string {
	if m != nil {
		return m.HealthCheckProtocol
	}
	return ""
}

func (m *DelayRegister) GetHealthCheckMethod() string {
	if m != nil {
		return m.HealthCheckMethod
	}
	return ""
}

func (m *DelayRegister) GetHealthCheckPath() string {
	if m != nil {
		return m.HealthCheckPath
	}
	return ""
}

func (m *DelayRegister) GetHealthCheckIntervalSecond() string {
	if m != nil {
		return m.HealthCheckIntervalSecond
	}
	return ""
}

type Warmup struct {
	// enable warmup
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	// total warmup interval by second
	IntervalSecond int32 `protobuf:"varint,2,opt,name=intervalSecond,json=interval_second,proto3" json:"intervalSecond,omitempty"`
	// warmup stop when most of the instances in service are in warmup status
	EnableOverloadProtection bool `protobuf:"varint,3,opt,name=enableOverloadProtection,json=enable_overload_protection,proto3" json:"enableOverloadProtection,omitempty"`
	// the threshold to active overload protection, default is 50, threshld = sum(WarmupInstances)/sum(AllInstances)*100
	OverloadProtectionThreshold int32 `protobuf:"varint,4,opt,name=overloadProtectionThreshold,json=overload_protection_threshold,proto3" json:"overloadProtectionThreshold,omitempty"`
	// curvature for warmup register, default is 1
	Curvature            int32    `protobuf:"varint,5,opt,name=curvature,proto3" json:"curvature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Warmup) Reset()         { *m = Warmup{} }
func (m *Warmup) String() string { return proto.CompactTextString(m) }
func (*Warmup) ProtoMessage()    {}
func (*Warmup) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{3}
}
func (m *Warmup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Warmup.Unmarshal(m, b)
}
func (m *Warmup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Warmup.Marshal(b, m, deterministic)
}
func (dst *Warmup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Warmup.Merge(dst, src)
}
func (m *Warmup) XXX_Size() int {
	return xxx_messageInfo_Warmup.Size(m)
}
func (m *Warmup) XXX_DiscardUnknown() {
	xxx_messageInfo_Warmup.DiscardUnknown(m)
}

var xxx_messageInfo_Warmup proto.InternalMessageInfo

func (m *Warmup) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *Warmup) GetIntervalSecond() int32 {
	if m != nil {
		return m.IntervalSecond
	}
	return 0
}

func (m *Warmup) GetEnableOverloadProtection() bool {
	if m != nil {
		return m.EnableOverloadProtection
	}
	return false
}

func (m *Warmup) GetOverloadProtectionThreshold() int32 {
	if m != nil {
		return m.OverloadProtectionThreshold
	}
	return 0
}

func (m *Warmup) GetCurvature() int32 {
	if m != nil {
		return m.Curvature
	}
	return 0
}

type Readiness struct {
	// enable /readiness expose
	Enable               bool     `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Readiness) Reset()         { *m = Readiness{} }
func (m *Readiness) String() string { return proto.CompactTextString(m) }
func (*Readiness) ProtoMessage()    {}
func (*Readiness) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{4}
}
func (m *Readiness) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Readiness.Unmarshal(m, b)
}
func (m *Readiness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Readiness.Marshal(b, m, deterministic)
}
func (dst *Readiness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Readiness.Merge(dst, src)
}
func (m *Readiness) XXX_Size() int {
	return xxx_messageInfo_Readiness.Size(m)
}
func (m *Readiness) XXX_DiscardUnknown() {
	xxx_messageInfo_Readiness.DiscardUnknown(m)
}

var xxx_messageInfo_Readiness proto.InternalMessageInfo

func (m *Readiness) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

type LosslessOffline struct {
	// enable /offline expose
	Enable               bool     `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LosslessOffline) Reset()         { *m = LosslessOffline{} }
func (m *LosslessOffline) String() string { return proto.CompactTextString(m) }
func (*LosslessOffline) ProtoMessage()    {}
func (*LosslessOffline) Descriptor() ([]byte, []int) {
	return fileDescriptor_lossless_ade064d0b0043b42, []int{5}
}
func (m *LosslessOffline) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LosslessOffline.Unmarshal(m, b)
}
func (m *LosslessOffline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LosslessOffline.Marshal(b, m, deterministic)
}
func (dst *LosslessOffline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LosslessOffline.Merge(dst, src)
}
func (m *LosslessOffline) XXX_Size() int {
	return xxx_messageInfo_LosslessOffline.Size(m)
}
func (m *LosslessOffline) XXX_DiscardUnknown() {
	xxx_messageInfo_LosslessOffline.DiscardUnknown(m)
}

var xxx_messageInfo_LosslessOffline proto.InternalMessageInfo

func (m *LosslessOffline) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func init() {
	proto.RegisterType((*LosslessRule)(nil), "v1.LosslessRule")
	proto.RegisterMapType((map[string]string)(nil), "v1.LosslessRule.MetadataEntry")
	proto.RegisterType((*LosslessOnline)(nil), "v1.LosslessOnline")
	proto.RegisterType((*DelayRegister)(nil), "v1.DelayRegister")
	proto.RegisterType((*Warmup)(nil), "v1.Warmup")
	proto.RegisterType((*Readiness)(nil), "v1.Readiness")
	proto.RegisterType((*LosslessOffline)(nil), "v1.LosslessOffline")
	proto.RegisterEnum("v1.DelayRegister_DelayStrategy", DelayRegister_DelayStrategy_name, DelayRegister_DelayStrategy_value)
}

func init() { proto.RegisterFile("lossless.proto", fileDescriptor_lossless_ade064d0b0043b42) }

var fileDescriptor_lossless_ade064d0b0043b42 = []byte{
	// 755 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x9e, 0xec, 0xd9, 0xb1, 0x8f, 0x67, 0xc7, 0x66, 0xd6, 0x41, 0xcd, 0xba, 0xd4, 0xd0, 0x2e,
	0xe6, 0x6d, 0x80, 0x8c, 0x78, 0x17, 0x2b, 0x9a, 0xfd, 0xa0, 0x4e, 0x0c, 0xa4, 0x98, 0x83, 0x0c,
	0x6a, 0x80, 0xa1, 0xbb, 0x11, 0x18, 0xea, 0xd8, 0x22, 0x2a, 0x89, 0x02, 0x49, 0x6b, 0xf0, 0x4b,
	0xec, 0x05, 0x86, 0xbd, 0xd3, 0x5e, 0x63, 0x6f, 0x51, 0x88, 0x92, 0x6c, 0xab, 0x69, 0xee, 0x74,
	0xbe, 0x9f, 0x43, 0xf2, 0xe3, 0x11, 0x61, 0x10, 0x09, 0xa5, 0x22, 0x54, 0xca, 0x4d, 0xa5, 0xd0,
	0x82, 0x34, 0xb2, 0x73, 0xe7, 0xbf, 0x26, 0x7c, 0xb6, 0x2c, 0x61, 0x6f, 0x13, 0x21, 0x19, 0x40,
	0x83, 0x07, 0xb6, 0x35, 0xb6, 0x26, 0x5d, 0xaf, 0xc1, 0x03, 0x62, 0xc3, 0x91, 0x42, 0x99, 0x71,
	0x86, 0x76, 0xc3, 0x80, 0x55, 0x49, 0x9e, 0x41, 0x37, 0xa1, 0x31, 0xaa, 0x94, 0x32, 0xb4, 0x9b,
	0x86, 0xdb, 0x03, 0xe4, 0x14, 0x3a, 0x12, 0x33, 0xae, 0xb8, 0x48, 0xec, 0x4f, 0x0d, 0xb9, 0xab,
	0xc9, 0xe7, 0xd0, 0x62, 0x9a, 0xc7, 0x68, 0xb7, 0x0c, 0x51, 0x14, 0x39, 0x1a, 0x1b, 0xb4, 0x5d,
	0xa0, 0xa6, 0x20, 0x17, 0xfb, 0x6d, 0xdf, 0x26, 0x11, 0x4f, 0xd0, 0x3e, 0x1a, 0x5b, 0x93, 0xde,
	0x8c, 0xb8, 0xd9, 0xb9, 0xbb, 0xac, 0x31, 0xde, 0x71, 0xa5, 0xf4, 0x85, 0x01, 0xc8, 0x2f, 0xb0,
	0x83, 0x6e, 0x57, 0x2b, 0xe3, 0xee, 0x18, 0xf7, 0x49, 0xcd, 0x5d, 0x50, 0xde, 0x70, 0x6f, 0x2f,
	0x10, 0xf2, 0x12, 0x3a, 0x31, 0x6a, 0x1a, 0x50, 0x4d, 0xed, 0xee, 0xb8, 0x39, 0xe9, 0xcd, 0xce,
	0x0e, 0x8d, 0x79, 0x60, 0xee, 0x4d, 0x29, 0x58, 0x24, 0x5a, 0x6e, 0xbd, 0x9d, 0x3e, 0x0f, 0x00,
	0x03, 0xae, 0xe9, 0x7d, 0x84, 0xf6, 0xd9, 0xd8, 0x9a, 0x74, 0xbc, 0x5d, 0x4d, 0xce, 0x00, 0x02,
	0x8c, 0x50, 0xa3, 0x61, 0x9f, 0x1b, 0xf6, 0x00, 0x39, 0xbd, 0x80, 0x7e, 0xad, 0x2d, 0x19, 0x42,
	0xf3, 0x1d, 0x6e, 0xcb, 0x6b, 0xc9, 0x3f, 0xf3, 0xb4, 0x32, 0x1a, 0x6d, 0xaa, 0x5b, 0x29, 0x8a,
	0x97, 0x8d, 0x17, 0x96, 0xf3, 0x8f, 0x05, 0x83, 0x7a, 0x30, 0xe4, 0x05, 0xf4, 0x03, 0x8c, 0xe8,
	0xd6, 0xc3, 0x35, 0x57, 0x1a, 0xa5, 0x69, 0xd4, 0x9b, 0x8d, 0xf2, 0xc3, 0x5c, 0x1d, 0x12, 0xde,
	0xc0, 0xe8, 0x7c, 0x59, 0xd6, 0xc4, 0x81, 0xf6, 0x5f, 0x54, 0xc6, 0x9b, 0xd4, 0xac, 0xd3, 0x9b,
	0x41, 0x6e, 0xf9, 0xc3, 0x20, 0x5e, 0xc9, 0x90, 0xef, 0xa1, 0x2b, 0x91, 0x06, 0x3c, 0x41, 0xa5,
	0xcc, 0x20, 0xf4, 0x66, 0xfd, 0x5c, 0xe6, 0x55, 0xa0, 0xb7, 0xe7, 0x9d, 0x7f, 0x9b, 0xd0, 0xaf,
	0x2d, 0x49, 0xbe, 0x80, 0x36, 0x26, 0x26, 0x08, 0xcb, 0x04, 0x51, 0x56, 0xe4, 0x02, 0x3a, 0x4a,
	0x4b, 0xaa, 0x71, 0xbd, 0x35, 0x8b, 0x0f, 0x66, 0xcf, 0x1f, 0xec, 0xb7, 0xa8, 0xde, 0x94, 0x32,
	0x6f, 0x67, 0x20, 0xdf, 0xc0, 0x80, 0x27, 0x1a, 0x65, 0x46, 0xa3, 0x37, 0xc8, 0x44, 0x12, 0x98,
	0x8d, 0xb5, 0xbc, 0xe3, 0x0a, 0xf5, 0x95, 0x81, 0xc9, 0x0c, 0x4e, 0x42, 0xa4, 0x91, 0x0e, 0x2f,
	0x43, 0x64, 0xef, 0x7e, 0xcf, 0x7f, 0x0c, 0x26, 0xa2, 0x72, 0x64, 0x9f, 0x14, 0x94, 0xcf, 0x72,
	0xce, 0x4f, 0x4b, 0x92, 0xb8, 0x30, 0x3a, 0xf0, 0xdc, 0xa0, 0x0e, 0x45, 0x50, 0xce, 0xf2, 0x49,
	0xcd, 0x11, 0x1b, 0x8a, 0x7c, 0x07, 0xc7, 0x87, 0x6b, 0x50, 0x1d, 0x96, 0x33, 0x3e, 0xaa, 0xf7,
	0xa7, 0x3a, 0x24, 0xbf, 0xc2, 0xd3, 0x03, 0xed, 0xeb, 0xfa, 0x19, 0x8e, 0x8c, 0xeb, 0x59, 0xcd,
	0xf5, 0xc1, 0x81, 0x9c, 0x9f, 0xcb, 0x7c, 0xab, 0x50, 0xc8, 0x08, 0xfa, 0x57, 0x8b, 0xe5, 0xab,
	0xb7, 0xfe, 0xfc, 0xad, 0x7f, 0xf7, 0xfa, 0x66, 0x31, 0xfc, 0x84, 0x3c, 0x85, 0x27, 0x3b, 0xe8,
	0x7a, 0xf1, 0x6a, 0x79, 0x77, 0xed, 0x5f, 0x5e, 0x2f, 0x2e, 0x7f, 0x1b, 0x5a, 0xce, 0xff, 0x16,
	0xb4, 0x8b, 0xfb, 0x7d, 0xf4, 0x62, 0x1e, 0x66, 0xdb, 0xf8, 0x78, 0xb6, 0x3f, 0x81, 0x5d, 0x58,
	0x6e, 0x33, 0x94, 0x91, 0xa0, 0x41, 0x1e, 0x2f, 0x32, 0x9d, 0xbf, 0x09, 0x4d, 0xd3, 0xf2, 0xb4,
	0xe0, 0x7d, 0x51, 0x0a, 0x4c, 0xc6, 0x85, 0x82, 0xcc, 0xe1, 0x4b, 0xf1, 0xc0, 0x77, 0x17, 0x4a,
	0x54, 0xa1, 0x88, 0x02, 0x73, 0x43, 0x2d, 0xef, 0xab, 0x8f, 0x38, 0x7d, 0x5d, 0x89, 0xf2, 0x37,
	0x8a, 0x6d, 0x64, 0x46, 0xf5, 0x46, 0x16, 0xaf, 0x4d, 0xcb, 0xdb, 0x03, 0xce, 0xd7, 0xd0, 0xdd,
	0xcd, 0xe8, 0x63, 0xa7, 0x75, 0xbe, 0x85, 0xe3, 0x0f, 0x1e, 0x8a, 0xc7, 0xa4, 0xf3, 0xbf, 0x2d,
	0xf8, 0x91, 0x89, 0xd8, 0xd5, 0x98, 0x30, 0x4c, 0xb4, 0x9b, 0x8a, 0x88, 0x4a, 0xae, 0x5c, 0x95,
	0x22, 0xe3, 0x2b, 0xce, 0x68, 0xbe, 0x3b, 0x97, 0xa6, 0x3c, 0x9f, 0x63, 0x2d, 0xe9, 0x6a, 0xc5,
	0x99, 0x1b, 0xd3, 0x84, 0xae, 0x71, 0xde, 0xaf, 0x16, 0x31, 0x23, 0xf8, 0xe7, 0xd5, 0x9a, 0xeb,
	0x70, 0x73, 0xef, 0x32, 0x11, 0x4f, 0xcb, 0x36, 0x31, 0xaa, 0x70, 0x5a, 0x6b, 0x35, 0x55, 0x62,
	0x23, 0x19, 0x4e, 0xd7, 0x62, 0x4a, 0x53, 0x3e, 0xcd, 0xce, 0xa7, 0x65, 0x53, 0xbf, 0x68, 0x7a,
	0xdf, 0x36, 0x23, 0xfb, 0xc3, 0xfb, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbb, 0x5a, 0xd4, 0xbb, 0xfa,
	0x05, 0x00, 0x00,
}
