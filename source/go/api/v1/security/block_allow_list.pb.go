// Code generated by protoc-gen-go. DO NOT EDIT.
// source: block_allow_list.proto

package security // import "github.com/polarismesh/specification/source/go/api/v1/security"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import model "github.com/polarismesh/specification/source/go/api/v1/model"
import _ "google.golang.org/protobuf/types/known/wrapperspb"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BlockAllowConfig_BlockAllowPolicy int32

const (
	BlockAllowConfig_ALLOW_LIST BlockAllowConfig_BlockAllowPolicy = 0
	BlockAllowConfig_BLOCK_LIST BlockAllowConfig_BlockAllowPolicy = 1
)

var BlockAllowConfig_BlockAllowPolicy_name = map[int32]string{
	0: "ALLOW_LIST",
	1: "BLOCK_LIST",
}
var BlockAllowConfig_BlockAllowPolicy_value = map[string]int32{
	"ALLOW_LIST": 0,
	"BLOCK_LIST": 1,
}

func (x BlockAllowConfig_BlockAllowPolicy) String() string {
	return proto.EnumName(BlockAllowConfig_BlockAllowPolicy_name, int32(x))
}
func (BlockAllowConfig_BlockAllowPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_block_allow_list_00c77e4ccfe90593, []int{1, 0}
}

// label type for gateway request
type BlockAllowConfig_MatchArgument_Type int32

const (
	// custom arguments
	BlockAllowConfig_MatchArgument_CUSTOM BlockAllowConfig_MatchArgument_Type = 0
	// header, match the http header, dubbo attachment, grpc header
	BlockAllowConfig_MatchArgument_HEADER BlockAllowConfig_MatchArgument_Type = 1
	// query, match the http query, dubbo argument
	BlockAllowConfig_MatchArgument_QUERY BlockAllowConfig_MatchArgument_Type = 2
	// caller service
	BlockAllowConfig_MatchArgument_CALLER_SERVICE BlockAllowConfig_MatchArgument_Type = 3
	// caller host ip
	BlockAllowConfig_MatchArgument_CALLER_IP BlockAllowConfig_MatchArgument_Type = 4
	// caller instance metadata
	BlockAllowConfig_MatchArgument_CALLER_METADATA BlockAllowConfig_MatchArgument_Type = 5
	// caller instance metadata
	BlockAllowConfig_MatchArgument_CALLEE_METADATA BlockAllowConfig_MatchArgument_Type = 6
)

var BlockAllowConfig_MatchArgument_Type_name = map[int32]string{
	0: "CUSTOM",
	1: "HEADER",
	2: "QUERY",
	3: "CALLER_SERVICE",
	4: "CALLER_IP",
	5: "CALLER_METADATA",
	6: "CALLEE_METADATA",
}
var BlockAllowConfig_MatchArgument_Type_value = map[string]int32{
	"CUSTOM":          0,
	"HEADER":          1,
	"QUERY":           2,
	"CALLER_SERVICE":  3,
	"CALLER_IP":       4,
	"CALLER_METADATA": 5,
	"CALLEE_METADATA": 6,
}

func (x BlockAllowConfig_MatchArgument_Type) String() string {
	return proto.EnumName(BlockAllowConfig_MatchArgument_Type_name, int32(x))
}
func (BlockAllowConfig_MatchArgument_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_block_allow_list_00c77e4ccfe90593, []int{1, 0, 0}
}

type BlockAllowListRule struct {
	// unique rule id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// unique rule name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// metadata for block allow list rules
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// service namespace
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// service name
	Service string `protobuf:"bytes,5,opt,name=service,proto3" json:"service,omitempty"`
	// rule description
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// rule priority
	Priority uint32 `protobuf:"varint,7,opt,name=priority,proto3" json:"priority,omitempty"`
	// rule enable
	Enable bool `protobuf:"varint,8,opt,name=enable,proto3" json:"enable,omitempty"`
	// ctime create time of the rules
	Ctime string `protobuf:"bytes,9,opt,name=ctime,proto3" json:"ctime,omitempty"`
	// mtime modify time of the rules
	Mtime string `protobuf:"bytes,10,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// etime enable time of the rules
	Etime string `protobuf:"bytes,11,opt,name=etime,proto3" json:"etime,omitempty"`
	// block or allow configuration
	BlockAllowConfig     []*BlockAllowConfig `protobuf:"bytes,12,rep,name=blockAllowConfig,json=block_allow_config,proto3" json:"blockAllowConfig,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BlockAllowListRule) Reset()         { *m = BlockAllowListRule{} }
func (m *BlockAllowListRule) String() string { return proto.CompactTextString(m) }
func (*BlockAllowListRule) ProtoMessage()    {}
func (*BlockAllowListRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_block_allow_list_00c77e4ccfe90593, []int{0}
}
func (m *BlockAllowListRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockAllowListRule.Unmarshal(m, b)
}
func (m *BlockAllowListRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockAllowListRule.Marshal(b, m, deterministic)
}
func (dst *BlockAllowListRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockAllowListRule.Merge(dst, src)
}
func (m *BlockAllowListRule) XXX_Size() int {
	return xxx_messageInfo_BlockAllowListRule.Size(m)
}
func (m *BlockAllowListRule) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockAllowListRule.DiscardUnknown(m)
}

var xxx_messageInfo_BlockAllowListRule proto.InternalMessageInfo

func (m *BlockAllowListRule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BlockAllowListRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockAllowListRule) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *BlockAllowListRule) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *BlockAllowListRule) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *BlockAllowListRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BlockAllowListRule) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *BlockAllowListRule) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *BlockAllowListRule) GetCtime() string {
	if m != nil {
		return m.Ctime
	}
	return ""
}

func (m *BlockAllowListRule) GetMtime() string {
	if m != nil {
		return m.Mtime
	}
	return ""
}

func (m *BlockAllowListRule) GetEtime() string {
	if m != nil {
		return m.Etime
	}
	return ""
}

func (m *BlockAllowListRule) GetBlockAllowConfig() []*BlockAllowConfig {
	if m != nil {
		return m.BlockAllowConfig
	}
	return nil
}

type BlockAllowConfig struct {
	// blocking target api
	Api *model.API `protobuf:"bytes,1,opt,name=api,proto3" json:"api,omitempty"`
	// arguments to match this config
	Arguments []*BlockAllowConfig_MatchArgument `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
	// block or allow as policy
	BlockAllowPolicy     BlockAllowConfig_BlockAllowPolicy `protobuf:"varint,3,opt,name=blockAllowPolicy,json=block_allow_policy,proto3,enum=v1.BlockAllowConfig_BlockAllowPolicy" json:"blockAllowPolicy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *BlockAllowConfig) Reset()         { *m = BlockAllowConfig{} }
func (m *BlockAllowConfig) String() string { return proto.CompactTextString(m) }
func (*BlockAllowConfig) ProtoMessage()    {}
func (*BlockAllowConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_block_allow_list_00c77e4ccfe90593, []int{1}
}
func (m *BlockAllowConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockAllowConfig.Unmarshal(m, b)
}
func (m *BlockAllowConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockAllowConfig.Marshal(b, m, deterministic)
}
func (dst *BlockAllowConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockAllowConfig.Merge(dst, src)
}
func (m *BlockAllowConfig) XXX_Size() int {
	return xxx_messageInfo_BlockAllowConfig.Size(m)
}
func (m *BlockAllowConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockAllowConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BlockAllowConfig proto.InternalMessageInfo

func (m *BlockAllowConfig) GetApi() *model.API {
	if m != nil {
		return m.Api
	}
	return nil
}

func (m *BlockAllowConfig) GetArguments() []*BlockAllowConfig_MatchArgument {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *BlockAllowConfig) GetBlockAllowPolicy() BlockAllowConfig_BlockAllowPolicy {
	if m != nil {
		return m.BlockAllowPolicy
	}
	return BlockAllowConfig_ALLOW_LIST
}

type BlockAllowConfig_MatchArgument struct {
	Type BlockAllowConfig_MatchArgument_Type `protobuf:"varint,1,opt,name=type,proto3,enum=v1.BlockAllowConfig_MatchArgument_Type" json:"type,omitempty"`
	// header key or query key
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// header value or query value
	Value                *model.MatchString `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BlockAllowConfig_MatchArgument) Reset()         { *m = BlockAllowConfig_MatchArgument{} }
func (m *BlockAllowConfig_MatchArgument) String() string { return proto.CompactTextString(m) }
func (*BlockAllowConfig_MatchArgument) ProtoMessage()    {}
func (*BlockAllowConfig_MatchArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_block_allow_list_00c77e4ccfe90593, []int{1, 0}
}
func (m *BlockAllowConfig_MatchArgument) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockAllowConfig_MatchArgument.Unmarshal(m, b)
}
func (m *BlockAllowConfig_MatchArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockAllowConfig_MatchArgument.Marshal(b, m, deterministic)
}
func (dst *BlockAllowConfig_MatchArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockAllowConfig_MatchArgument.Merge(dst, src)
}
func (m *BlockAllowConfig_MatchArgument) XXX_Size() int {
	return xxx_messageInfo_BlockAllowConfig_MatchArgument.Size(m)
}
func (m *BlockAllowConfig_MatchArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockAllowConfig_MatchArgument.DiscardUnknown(m)
}

var xxx_messageInfo_BlockAllowConfig_MatchArgument proto.InternalMessageInfo

func (m *BlockAllowConfig_MatchArgument) GetType() BlockAllowConfig_MatchArgument_Type {
	if m != nil {
		return m.Type
	}
	return BlockAllowConfig_MatchArgument_CUSTOM
}

func (m *BlockAllowConfig_MatchArgument) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *BlockAllowConfig_MatchArgument) GetValue() *model.MatchString {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*BlockAllowListRule)(nil), "v1.BlockAllowListRule")
	proto.RegisterMapType((map[string]string)(nil), "v1.BlockAllowListRule.MetadataEntry")
	proto.RegisterType((*BlockAllowConfig)(nil), "v1.BlockAllowConfig")
	proto.RegisterType((*BlockAllowConfig_MatchArgument)(nil), "v1.BlockAllowConfig.MatchArgument")
	proto.RegisterEnum("v1.BlockAllowConfig_BlockAllowPolicy", BlockAllowConfig_BlockAllowPolicy_name, BlockAllowConfig_BlockAllowPolicy_value)
	proto.RegisterEnum("v1.BlockAllowConfig_MatchArgument_Type", BlockAllowConfig_MatchArgument_Type_name, BlockAllowConfig_MatchArgument_Type_value)
}

func init() {
	proto.RegisterFile("block_allow_list.proto", fileDescriptor_block_allow_list_00c77e4ccfe90593)
}

var fileDescriptor_block_allow_list_00c77e4ccfe90593 = []byte{
	// 662 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0x5f, 0x6f, 0xda, 0x3a,
	0x18, 0xc6, 0x9b, 0x04, 0x28, 0xbc, 0x1c, 0x68, 0xe4, 0x56, 0x55, 0x0e, 0x3a, 0x3a, 0x42, 0xe8,
	0x54, 0x87, 0xab, 0x44, 0x70, 0x6e, 0x8e, 0x56, 0x69, 0x6a, 0xa0, 0x91, 0x86, 0x06, 0x2a, 0x0b,
	0x74, 0xd3, 0x76, 0x83, 0x8c, 0x71, 0xa9, 0xd5, 0x24, 0x8e, 0x12, 0x43, 0xc5, 0x37, 0xd8, 0x77,
	0xdb, 0x17, 0xda, 0xcd, 0xa4, 0xc9, 0x4e, 0xf8, 0xd7, 0x55, 0xda, 0x9d, 0x9f, 0x9f, 0xed, 0xc7,
	0x7e, 0x9f, 0x57, 0x36, 0x5c, 0xce, 0x03, 0x4e, 0x9e, 0x66, 0x38, 0x08, 0xf8, 0xf3, 0x2c, 0x60,
	0xa9, 0xb0, 0xe3, 0x84, 0x0b, 0x8e, 0xf4, 0x75, 0xa7, 0xf1, 0xf7, 0x92, 0xf3, 0x65, 0x40, 0x1d,
	0x45, 0xe6, 0xab, 0x07, 0xe7, 0x39, 0xc1, 0x71, 0x4c, 0x93, 0x34, 0x5b, 0xd3, 0xa8, 0x86, 0x7c,
	0x41, 0x83, 0x4c, 0xb4, 0xbe, 0x19, 0x80, 0x7a, 0xd2, 0xcb, 0x95, 0x56, 0x43, 0x96, 0x0a, 0x7f,
	0x15, 0x50, 0x54, 0x07, 0x9d, 0x2d, 0x2c, 0xad, 0xa9, 0xb5, 0x2b, 0xbe, 0xce, 0x16, 0x08, 0x41,
	0x21, 0xc2, 0x21, 0xb5, 0x74, 0x45, 0xd4, 0x18, 0xdd, 0x40, 0x39, 0xa4, 0x02, 0x2f, 0xb0, 0xc0,
	0x96, 0xd1, 0x34, 0xda, 0xd5, 0xee, 0x3f, 0xf6, 0xba, 0x63, 0xff, 0xea, 0x66, 0x8f, 0xf2, 0x65,
	0x5e, 0x24, 0x92, 0x8d, 0xbf, 0xdb, 0x85, 0xfe, 0x82, 0x8a, 0x74, 0x4a, 0x63, 0x4c, 0xa8, 0x55,
	0x50, 0xd6, 0x7b, 0x80, 0x2c, 0x38, 0x4d, 0x69, 0xb2, 0x66, 0x84, 0x5a, 0x45, 0x35, 0xb7, 0x95,
	0xa8, 0x09, 0xd5, 0x05, 0x4d, 0x49, 0xc2, 0x62, 0xc1, 0x78, 0x64, 0x95, 0xd4, 0xec, 0x21, 0x42,
	0x0d, 0x28, 0xc7, 0x09, 0xe3, 0x09, 0x13, 0x1b, 0xeb, 0xb4, 0xa9, 0xb5, 0x6b, 0xfe, 0x4e, 0xa3,
	0x4b, 0x28, 0xd1, 0x08, 0xcf, 0x03, 0x6a, 0x95, 0x9b, 0x5a, 0xbb, 0xec, 0xe7, 0x0a, 0x5d, 0x40,
	0x91, 0x08, 0x16, 0x52, 0xab, 0xa2, 0xfc, 0x32, 0x21, 0x69, 0xa8, 0x28, 0x64, 0x34, 0xdc, 0x52,
	0xaa, 0x68, 0x35, 0xa3, 0x4a, 0xa0, 0x1e, 0x98, 0xf3, 0x5d, 0xf5, 0x7d, 0x1e, 0x3d, 0xb0, 0xa5,
	0xf5, 0x87, 0x4a, 0xe6, 0xe2, 0x38, 0x99, 0x6c, 0xce, 0x47, 0x87, 0x5d, 0x24, 0x8a, 0x35, 0xae,
	0xa1, 0x76, 0x14, 0x17, 0x32, 0xc1, 0x78, 0xa2, 0x9b, 0xbc, 0x17, 0x72, 0x28, 0x0f, 0x5f, 0xe3,
	0x60, 0xb5, 0xed, 0x46, 0x26, 0xde, 0xe8, 0xff, 0x6b, 0xad, 0xef, 0x06, 0x98, 0x2f, 0x4f, 0x41,
	0x7f, 0x82, 0x81, 0x63, 0xa6, 0x0c, 0xaa, 0xdd, 0x53, 0x79, 0x11, 0x77, 0x3c, 0xf0, 0x25, 0x43,
	0x37, 0x50, 0xc1, 0xc9, 0x72, 0x15, 0xd2, 0x48, 0xa4, 0x96, 0xae, 0x6e, 0xda, 0x7a, 0xed, 0xa6,
	0xf6, 0x08, 0x0b, 0xf2, 0xe8, 0xe6, 0x4b, 0xfd, 0xfd, 0x26, 0x34, 0x39, 0x2c, 0x79, 0xcc, 0x03,
	0x46, 0x36, 0x96, 0xd1, 0xd4, 0xda, 0xf5, 0xee, 0xd5, 0xab, 0x46, 0xbd, 0x17, 0x8b, 0x8f, 0x33,
	0x88, 0x15, 0x6b, 0xfc, 0xd0, 0xa0, 0x76, 0x74, 0x22, 0xba, 0x86, 0x82, 0xd8, 0xc4, 0x54, 0x15,
	0x51, 0xef, 0xfe, 0xfb, 0xfb, 0x3b, 0xda, 0xd3, 0x4d, 0x4c, 0x7d, 0xb5, 0x69, 0x9b, 0xa0, 0xbe,
	0x4f, 0xf0, 0x6a, 0x9b, 0xa0, 0xa1, 0x42, 0x39, 0x93, 0x7e, 0x6a, 0xfb, 0x44, 0x24, 0x2c, 0x5a,
	0xe6, 0x91, 0xb6, 0xd6, 0x50, 0x90, 0x36, 0x08, 0xa0, 0xd4, 0xbf, 0x9f, 0x4c, 0xef, 0x46, 0xe6,
	0x89, 0x1c, 0xbf, 0xf3, 0xdc, 0x5b, 0xcf, 0x37, 0x35, 0x54, 0x81, 0xe2, 0x87, 0x7b, 0xcf, 0xff,
	0x6c, 0xea, 0x08, 0x41, 0xbd, 0xef, 0x0e, 0x87, 0x9e, 0x3f, 0x9b, 0x78, 0xfe, 0xc7, 0x41, 0xdf,
	0x33, 0x0d, 0x54, 0x83, 0x4a, 0xce, 0x06, 0x63, 0xb3, 0x80, 0xce, 0xe1, 0x2c, 0x97, 0x23, 0x6f,
	0xea, 0xde, 0xba, 0x53, 0xd7, 0x2c, 0xee, 0xa0, 0xb7, 0x87, 0xa5, 0x56, 0xf7, 0xb0, 0x8b, 0x59,
	0x4e, 0xa8, 0x0e, 0xe0, 0x0e, 0x87, 0x77, 0x9f, 0x66, 0xc3, 0xc1, 0x64, 0x6a, 0x9e, 0x48, 0xdd,
	0x1b, 0xde, 0xf5, 0xdf, 0x67, 0x5a, 0xeb, 0x7d, 0xd5, 0xa0, 0x43, 0x78, 0x68, 0x0b, 0x1a, 0x11,
	0x59, 0x7f, 0xcc, 0x03, 0x9c, 0xb0, 0xd4, 0x4e, 0x63, 0x4a, 0xd8, 0x03, 0x23, 0x58, 0xbe, 0x0b,
	0x1b, 0xc7, 0x4c, 0xd6, 0x9a, 0x52, 0xb2, 0x92, 0x6f, 0xa1, 0x77, 0x7e, 0xfc, 0x5a, 0xc7, 0xf2,
	0x4f, 0xf8, 0xf2, 0x76, 0xc9, 0xc4, 0xe3, 0x6a, 0x6e, 0x13, 0x1e, 0x3a, 0xb9, 0x4d, 0x48, 0xd3,
	0x47, 0xe7, 0xc8, 0xca, 0x49, 0xf9, 0x2a, 0x21, 0xd4, 0x59, 0x72, 0x07, 0xc7, 0xcc, 0x59, 0x77,
	0x9c, 0xad, 0xe9, 0xbc, 0xa4, 0xbe, 0x96, 0xff, 0x7e, 0x06, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x87,
	0x3e, 0x02, 0xa5, 0x04, 0x00, 0x00,
}
